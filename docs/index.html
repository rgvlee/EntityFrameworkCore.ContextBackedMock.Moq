<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>EntityFrameworkCore.DbContextBackedMock.Moq </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="EntityFrameworkCore.DbContextBackedMock.Moq ">
    <meta name="generator" content="docfx 2.43.2.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="entityframeworkcoredbcontextbackedmockmoq">EntityFrameworkCore.DbContextBackedMock.Moq</h1>

<p>EntityFrameworkCore.DbContextBackedMock.Moq allows you to create a mock DbContext (and mock DbSets) and have it
backed by an actual DbContext. It's basically a delegate pattern implementation where the mock for the most part
is delegating over the top of the DbContext.</p>
<p>If it's just a wrapper, why bother using it? There's a couple of reasons.</p>
<p>It's designed to work with the Microsoft InMemory provider (<a href="https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory">https://docs.microsoft.com/en-us/ef/core/miscellaneous/testing/in-memory</a>) that is
often used for testing. The InMemory provider is great for most cases however it doesn't do everything. That's where
this library steps in. It has specific functionality to allow operations involving the FromSql extension to be included
in your tests, as well as all of the benefits of using a mocking framework (e.g., the ability to verify method invocation).</p>
<p>If your using the InMemory provider and you need to mock FromSql or want the additional coverage provided by Moq,
this library will do the heavy lifting for you.</p>
<p>Consumption is via a builder. Create the builder, tell it what DbSets to mock, add any FromSql mocks and off you go.</p>
<h1 id="quick-start">Quick Start</h1>
<h2 id="example-usage">Example Usage</h2>
<ul>
<li>Create an in memory DbContext</li>
<li>Create the builder</li>
<li>Setup the mock DbSet</li>
<li>Get the db context mock</li>
<li>Consume</li>
</ul>
<p>Operations on the mock DbContext are funnelled through to the in memory DbContext. You can add/update/remove on either and both will yield the same result.</p>
<pre><code>[Test]
public void Add_NewEntity_Persists() {
    var contextToMock = new TestContext(new DbContextOptionsBuilder&lt;TestContext&gt;().UseInMemoryDatabase(Guid.NewGuid().ToString()).Options);
    var builder = new DbContextMockBuilder&lt;TestContext&gt;(contextToMock).AddSetUpDbSetFor&lt;TestEntity1&gt;();
    var mockContext = builder.GetDbContextMock();

    var context = mockContext.Object;
    var testEntity1 = new TestEntity1();
    Assert.AreEqual(default(Guid), testEntity1.Id);

    context.Set&lt;TestEntity1&gt;().Add(testEntity1);
    context.SaveChanges();
    Assert.AreNotEqual(default(Guid), testEntity1.Id);

    Assert.AreEqual(testEntity1, contextToMock.Find&lt;TestEntity1&gt;(testEntity1.Id));
    Assert.AreEqual(testEntity1, context.Find&lt;TestEntity1&gt;(testEntity1.Id));

    mockContext.Verify(m =&gt; m.SaveChanges(), Times.Once);
}
</code></pre>
<h3 id="testing-fromsql">Testing FromSql</h3>
<p>The main difference here is that we need the seed data to set up query provider to return the expected result.
Create in memory DbContext/mock DbContext/generate seed data/create and set up/invoke FromSql.
In this case we didn't need to persist the seed data; it will depend on implementation of your FromSql usage (e.g., if FromSql is invoked with a repository
and the operation invokes other DbContext/DbSet operations you may need to persist the seed data).</p>
<pre><code>[Test]
public void FromSql_AnyStoredProcedureWithNoParameters_ReturnsExpectedResult() {
    var contextToMock = new TestContext(new DbContextOptionsBuilder&lt;TestContext&gt;().UseInMemoryDatabase(Guid.NewGuid().ToString()).Options);
    var builder = new DbContextMockBuilder&lt;TestContext&gt;(contextToMock);

    var testEntity1 = new TestEntity1();
    var list1 = new List&lt;TestEntity1&gt; { testEntity1 };

    builder.AddSetUpDbSetFor&lt;TestEntity1&gt;().WithFromSqlResult(list1.AsQueryable());

    var mockContext = builder.GetDbContextMock();
    var context = mockContext.Object;

    var result = context.Set&lt;TestEntity1&gt;().FromSql(&quot;sp_NoParams&quot;).ToList();

    Assert.IsNotNull(result);
    Assert.IsTrue(result.Any());
    CollectionAssert.AreEquivalent(list1, result);
}
</code></pre>
<h3 id="testing-fromsql-with-sqlparameters">Testing FromSql with SqlParameters</h3>
<p>Expanding on the previous example, for this test we create a mock query provider and specify</p>
<ul>
<li>The FromSql sql that we want to match;</li>
<li>A sequence of FromSql SqlParameters</li>
</ul>
<p>The FromSql sql set up is based on a case insensitive contains; in the example we're able to match on just the stored procedure name.
The FromSql SqlParameters, if provided to the query provider mock, must be provided in the FromSql invocation for a match to occur. Again, the match is case insensitive as demonstrated below.
Only FromSql SqlParameters provided to the query provider mock will be checked. All others will be ignored so you only need to specify the bare minimum for a mock setup match.</p>
<pre><code>[Test]
public void FromSql_SpecifiedStoredProcedureWithParameters_ReturnsExpectedResult() {
    var contextToMock = new TestContext(new DbContextOptionsBuilder&lt;TestContext&gt;().UseInMemoryDatabase(Guid.NewGuid().ToString()).Options);
    var builder = new DbContextMockBuilder&lt;TestContext&gt;(contextToMock);

    var testEntity1 = new TestEntity1();
    var list1 = new List&lt;TestEntity1&gt; { testEntity1 };

    var mockQueryProvider = new Mock&lt;IQueryProvider&gt;();
    var sqlParameter = new SqlParameter(&quot;@SomeParameter2&quot;, &quot;Value2&quot;);
    mockQueryProvider.SetUpFromSql(&quot;sp_Specified&quot;, new List&lt;SqlParameter&gt; { sqlParameter }, list1.AsQueryable());
    builder.AddSetUpDbSetFor&lt;TestEntity1&gt;().WithQueryProviderMock(mockQueryProvider);

    var mockContext = builder.GetDbContextMock();
    var context = mockContext.Object;

    var result = context.Set&lt;TestEntity1&gt;().FromSql(&quot;[dbo].[sp_Specified] @SomeParameter1 @SomeParameter2&quot;, new SqlParameter(&quot;@someparameter2&quot;, &quot;Value2&quot;)).ToList();

    Assert.IsNotNull(result);
    Assert.IsTrue(result.Any());
    CollectionAssert.AreEquivalent(list1, result);
}
</code></pre>
<h2 id="fluent-interface">Fluent interface</h2>
<p>The builder provides a fluent interface for both DbContext and DbSet mocks. I've designed the API to be intuitive and discoverable. The examples above do touch on a bit of the available functionality.
There are actually 2 builders, 1 for the DbContext and one for DbSets. Once you invoke a DbSet method you'll get the DbSet builder. This is deliberate as it provides explicit entity DbSet set up scoping.</p>
<h2 id="the-disclaimer">The disclaimer</h2>
<p>The library sets up a lot of the DbContext functionality but not all of it. I have built this based on my current needs. If you find this library useful and need additional behaviour mocked flick me a message and I'll see what I can do.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/rgvlee/EntityFrameworkCore.DbContextBackedMock.Moq/blob/master/EntityFrameworkCore.DbContextBackedMock.Moq/index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
